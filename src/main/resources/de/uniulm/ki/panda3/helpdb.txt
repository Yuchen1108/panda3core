%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
main
---- no text necessary
Available options for PANDA3:

To run PANDA3, you have to specify at least a domain and a problem file.
For most parameters, their order does not matter.
Parameters can be freely interleaved with the specification of a domain, problem, and output file.
\n
PANDA3's general call syntax is as follows:
    java -jar panda3.jar [OPTIONS] domfile.xyz [OPTIONS] probfile.xyz [OPTIONS] [outputfile.{pdf|dot}] [OPTIONS]
$ -help -printGeneralInfo -noGeneralInfo -printAdditionalInfo -noAdditionalInfo -timelimit -planSearch -noSearch -search -heuristic -seed -parser






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-help
Explains how -help [OPTION or KEY] works.
Available options for -help:

Run "-help [OPTION or KEY]" to show help for the respective option or key.
$







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-parser
Select the parser for the input files.
Available parsers:

We support various different input formats for our planner. Default value is "auto", which should select the correct parser depending on the input file.
$ xml old-pddl pddl hpddl hddl auto





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
xml
Parser for our PANDA XML standard.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "xml" IS A KEY, NOT AN OPTION.

We do not posses a description of our XML-based input specification. We also do not provide support, since we will abandon that format in favor of hddl, a new input language HDDL that we are currently developing.
$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
hddl
Parser for our HDDL standard.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "hddl" IS A KEY, NOT AN OPTION.

HDDL is a novel input language for hierarchical planning problems that we are currently developing. For questions regarding this standard, please contact Daniel Höller.
$


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
hpddl
Parser for our HPDDL standard.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "hpddl" IS A KEY, NOT AN OPTION.

HPDDL is a is a predecessor of our new language HPDDL. We stopped its development.
$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
pddl
Parser for the PDDL standard.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "pddl" IS A KEY, NOT AN OPTION.

This is the parser for the well-known PDDL standard.
$








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
old-pddl
Parser for PDDL without types.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "old-pddl" IS A KEY, NOT AN OPTION.

The parser for old-pddl is a PDDL parser that can read the older PDDL standard in which there are no types.
$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
auto
Automatic parser selection.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "auto" IS A KEY, NOT AN OPTION.

This option chooses the parser automatically depending on the input file. If this works correctly, no other parser needs to be selected.
$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-printGeneralInfo
Shows additional information during planning.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "-printGeneralInfo" IS A SWITCH, NOT AN OPTION.

When using this command, the planner will show -- during planning -- what it is currently doing, such as constructing the planning graph, etc.
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-noGeneralInfo
Suppress additional information during planning.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "-noGeneralInfo" IS A SWITCH, NOT AN OPTION.

When using this command, the planner will suppress additional information that is otherwise shown during planning. This information explains what the planner is currently doing, such as, for example, constructing the planning graph.
$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-printAdditionalInfo
Shows information about compilations steps.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "-printAdditionalInfo" IS A SWITCH, NOT AN OPTION.

Many of our heuristics base upon very basic language features, that is: a ground model in which primitive tasks have only positive preconditions. Also our decomposition methods do not have preconditions (as opposed to the SHOP2 model) or effects (yes, some hierarchical planning formalisms even allow effects of methods). We compile all these higher-level language features away. Activating this switch prints additional information about these compilations after each single compilation step.
$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-noAdditionalInfo
Suppresses information about compilations steps.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "-noAdditionalInfo" IS A SWITCH, NOT AN OPTION.

Many of our heuristics base upon very basic language features, that is: a ground model in which primitive tasks have only positive preconditions. Also our decomposition methods do not have preconditions (as opposed to the SHOP2 model) or effects (yes, some hierarchical planning formalisms even allow effects of methods). We compile all these higher-level language features away. Activating this switch suppresses additional information about these compilations after each single compilation step.
$



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-planSearch
Uses the "traditional" PANDA3, decompositional-based.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "-planSearch" IS A SWITCH, NOT AN OPTION.

PANDA3 is more than just "one planning system". Apart from additional capabilities like repairing and explaining plans (not yet provided online), or validating plans, we also have three differently working planners (only two of which are provided online at the moment). While these planners share the same preprocessing, e.g., grounding, they are completely different in the way they solve problems.
\n
This planner configuration uses the "traditional" PANDA3, which performs search in the space of partial plans. We refer to its search procedure as hybrid planning, because it fuses hierarchical planning with partial order causal link (POCL) planning. The algorithm is a standard flaw-based POCL algorithm that can additionally cope with abstract tasks. It is explained in the following paper:
\n
Hybrid Planning Heuristics Based on Task Decomposition Graphs
by Pascal Bercher and Shawn Keen and Susanne Biundo
published in SoCS 2014 by AAAI Press.
\n
Please note that this plan space-based planning algorithm requires a search algorithm (like BFS or A*) and a flaw selection function.
\n
We further want to note that this planner is able of solving a broad variety of problem classes, including HTN problems, TIHTN problems (HTN problems with task insertion), hybrid problems with or without task insertion (these problems extend HTN/TIHTN problems via preconditions and effects of abstract tasks and by causal links in the domain model's partial plans), classical problems, and POCL problems (which are like classical problems, but with an initial primitive partial plan). Please note that the property whether task insertion is allowed cannot be passed on to the planner as an option, but it needs to be specified in the domain or problem file, since this is not an algorithmic choice, but a property of the problem (class) that is solved.
$






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-noSearch
Terminate after the preprocessing.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "-printGeneralInfo" IS A SWITCH, NOT AN OPTION.

This option is mainly for debugging purposes: choosing it will cause the planner to terminate as soon as it finished all preprocessing steps, i.e., right before it would initiate the search.
$








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-search
Choose the search strategy.
Available search strategies:

Using "--search [KEY]" allows to select the search strategy given plan-based search ("traditional PANDA3") was selected.
$ bfs dfs greedy uniform-cost a* depth-a*





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
bfs
Breadth-first Search.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "bfs" IS A KEY, NOT AN OPTION.

This is the standard breadth-first search strategy as described in the text books using a queue.
$



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
dfs
Depth-first Search.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "dfs" IS A KEY, NOT AN OPTION.

This is the standard depth-first search strategy as described in the text books using a stack.
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
greedy
Greedy Search.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "greedy" IS A KEY, NOT AN OPTION.

This is standard greedy search, i.e., you must also define a heuristic.
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
dijkstra uniform-cost
Uniform cost search.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "dijkstra" IS A KEY, NOT AN OPTION.

This is standard dijkstra algorithm, that is, standard uniform-cost search. Thus, action costs are ignored and assumed being equal to one instead.
$







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
astar a*
A*, f(n)=w*g(n)+h(n), w weight, g cost, h heuristic
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "a*" IS A KEY, NOT AN OPTION.

This is weighted A*, i.e., search nodes n are selected according to their value f(n)=w*g(n)+h(n), where w is a weight, g(n) is the node's action cost and h(n) is its heuristic value. Please note that our planners currently do not support action costs, i.e., we assume cost 1 for each primitive action.
\n
If you just select this heuristic, standard A* search is performed. For weighted A*, add the weight in parentheses, e.g., astar(2).

$






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
depth-astar depth-a*
A*, f(n)=d(n)+h(n), w weight, d depth, h heuristic
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "depth-astar" IS A KEY, NOT AN OPTION.
% Auch astar-depth und a*-depth wäre möglich, aber

This is weighted A*, i.e., search nodes n are selected according to their value f(n)=w*d(n)+h(n), but d(n) is the depth in the search tree rather than the cost of the current search node as usual; w is the weight and h(n) is its heuristic value.
\n
If you just select this heuristic, standard depth-A* search is performed. For weighted depth-A*, add the weight in parentheses, e.g., depth-astar(2).
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-flaw -f
Choose a flaw selection strategy.
Available flaw selection strategies:

Using "-flaw [KEY]" allows to select a flaw selection strategy for the plan space-based search algorithm.
$ lcfr random





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
lcfr
Least-Cost Flaw-Repair.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "lcfr" IS A KEY, NOT AN OPTION.

The flaw selection strategy lcfr, Least-Cost Flaw-Repair, was introduced in the following paper:
\n
Least-Cost Flaw Repair: A Plan Refinement Strategy for Partial-Order Planning
by David Joslin and Martha E. Pollack
published in AAAI 1994 by AAAI Press.
\n
That strategy is both extremely simple and efficient: it always selects a flaw for which there are the least number of "repairs", i.e., plan modifications. That way, the branching factor of the explored search space is locally minimized, which shows empirically good results on average.
$








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-heuristic -h
Choose one of many heuristics.
Available heuristics:

Using "-heuristic [KEY]" allows to select one of many heuristics that is used for the plan selection function. Please note that most of the heuristics are developed for the plan space-based search algorithm, but some of them also (or exclusively) work for the progression-based planner. We will be clear about this in the respective heuristics. Most heuristics have additional arguments, which can be passed on using the following syntax:
    -heuristic HEURISTIC_NAME(PARAM1=VALUE1,PARAM2=VALUE2)
$ random #flaw #oc number-of-open-preconditions #ps number-of-plan-steps #abstract number-of-abstract-plan-steps grounding-mme-with-cycle-detection grounding-pr grounding-tdg-mac add add_r add-r add_reusing add-reusing relax










%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
random
Returns random integers.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "random" IS A KEY, NOT AN OPTION.

This plan selection heuristic for the plan space-based PANDA3 algorithm returns a random integer. It is initialized with the default random seed.
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#flaw number-of-flaws
Number of flaws.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "#flaw" IS A KEY, NOT AN OPTION.

This plan selection heuristic for the plan space-based PANDA3 algorithm returns the number of flaws of the respective plan.
\n
Please note that this heuristic only works for the plan space-based PANDA3 algorithm. It works both for ground and for lifted planning. It works for all problem classes that can be solved by PANDA3.
$






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#oc number-of-open-preconditions
Number of open preconditions.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "#oc" IS A KEY, NOT AN OPTION.

This plan selection heuristic for the plan space-based PANDA3 algorithm returns the number of open preconditions.
\n
Please note that this heuristic only works for the plan space-based PANDA3 algorithm. It works both for ground and for lifted planning. It works for all problem classes that can be solved by PANDA3.
$







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#ps number-of-plan-steps
Number of plan steps.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "#ps" IS A KEY, NOT AN OPTION.

This plan selection heuristic for the plan space-based PANDA3 algorithm returns the number of plan steps in a partial plan (excluding the artificial start and end steps).
\n
Please note that this heuristic only works for the plan space-based PANDA3 algorithm. It works both for ground and for lifted planning. It works for all problem classes that can be solved by PANDA3.
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#abstract number-of-abstract-plan-steps
Number of abstract plan steps.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "#abstract" IS A KEY, NOT AN OPTION.

This plan selection heuristic for the plan space-based PANDA3 algorithm returns the number of abstract plan steps in a partial plan.
\n
Please note that this heuristic only works for the plan space-based PANDA3 algorithm. It works both for ground and for lifted planning. It works for all hierarchical problem classes that can be solved by PANDA3 (for the non-hierarchical ones, it returns 0, of course).
$








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
grounding-mme-with-cycle-detection
Unklar, Gregor
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "grounding-mme-with-cycle-detection" IS A KEY, NOT AN OPTION.

Unklar, Gregor. Hat mögliche Parameter never, reachability und causal-link; erwähnen!
$







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
grounding-pr
Unklar, Gregor
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "grounding-pr" IS A KEY, NOT AN OPTION.

Unklar, Gregor.
$






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
grounding-tdg-mac
Unklar, Gregor
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "grounding-tdg-mac" IS A KEY, NOT AN OPTION.

Unklar, Gregor.
$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
add
This is the Add heuristic for POCL planning.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "add" IS A KEY, NOT AN OPTION.

This plan selection heuristic for the plan space-based PANDA3 algorithm is the Add heuristic for POCL planning as desribed in the following paper:
\n
VHPOP: Versatile heuristic partial order planner
by Hakan L. S. Younes and Reid G. Simmons
published in the Journal of Artificial Intelligence Research (JAIR), 2003.
\n
In a nutshell, this heuristic takes all open preconditions of the current partial plan (i.e., those that are not protected by a causal link) and uses them as goal state the achievement of which is estimated relying on the Add heuristic for classical planning (however, the underlying planning graph is calculated only once, because the "current state" is always the initial state).
\n
Please note that this heuristic can not only be applied to non-hierarchical problems, but to all that can be solved by PANDA3. In case of hierarchical problems, the heuristic either ignores abstract tasks (in case they do not have preconditions, as is the case of HTN and TIHTN problems) or they are "regarded primitive", i.e. their preconditions are used as well in case they have some specified (as is the case for hybrid problems).
$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
add-r add-reusing add_r add_reusing
This is the Add heuristic for POCL planning reusing actions.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "add-r" IS A KEY, NOT AN OPTION.

This plan selection heuristic for the plan space-based PANDA3 algorithm is the Add heuristic for POCL planning reusing actions as desribed in the following paper:
\n
VHPOP: Versatile heuristic partial order planner
by Hakan L. S. Younes and Reid G. Simmons
published in the Journal of Artificial Intelligence Research (JAIR), 2003.
\n
In a nutshell, this heuristic takes *some* of the open preconditions of the current partial plan (i.e., a subset of those that are not protected by a causal link) and uses them as goal state the achievement of which is estimated relying on the Add heuristic for classical planning (however, the underlying planning graph is calculated only once, because the "current state" is always the initial state). Instead of taking *all* unprotected preconditions (as the Add heuristic for POCL planning does), the Add-r heuristic only takes those open preconditions for which there is no action in the current partial plan that can, occording to the ordering and variable constraints, potentially be used as a supporter.
\n
As it is the case for the Add heuristic for POCL planning, this heuristic can not only be applied to non-hierarchical problems, but to all that can be solved by PANDA3. In case of hierarchical problems, the heuristic either ignores abstract tasks (in case they do not have preconditions, as is the case of HTN and TIHTN problems) or they are "regarded primitive", i.e. their preconditions are used as well in case they have some specified (as is the case for hybrid problems).
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
relax
This is the Relax heuristic for POCL planning.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "relax" IS A KEY, NOT AN OPTION.

This plan selection heuristic for the plan space-based PANDA3 algorithm is the Relax heuristic as desribed in the following paper:
\n
Reviving Partial Order Planning
by XuanLong Nguyen and Subbarao Kambhampati
published in IJCAI 2001 by Morgan Kaufmann
\n
In a nutshell, this heuristic takes all open preconditions of the current partial plan (i.e., those that are not protected by a causal link) and uses them as goal state the achievement of which is estimated relying on the FF heuristic for classical planning (however, the underlying (serial) planning graph is calculated only once, because the "current state" is always the initial state). The cost of the extracted relaxed plan is used as heuristic. However, actions in that relaxed plan that do also occur in the input partial plan do not contribute towards the heuristic.
\n
As it is the case for the Add and Add-r heuristic for POCL planning, this heuristic can not only be applied to non-hierarchical problems, but to all that can be solved by PANDA3. In case of hierarchical problems, the heuristic either ignores abstract tasks (in case they do not have preconditions, as is the case of HTN and TIHTN problems) or they are "regarded primitive", i.e. their preconditions are used as well in case they have some specified (as is the case for hybrid problems).
$






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-timelimit
Sets the time limit in seconds.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "-timelimit" TAKES AN INTEGER, NO OPTIONS.

Using "-timelimit [INT]" sets the time limit in seconds.
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-seed
Sets the initial random seed.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "-seed" TAKES AN INTEGER, NO OPTIONS.

Using "-seed [INT]" sets the initial random seed to the specified integer. Otherwise, the pre-defined value 42 is used.
\n
Random seeds are used to systematically evaluate the impact of randomness in our systems. When ever some choice is made arbitrary (for instance, if search nodes are still invariant after breaking ties according to the given tie-breaking strategy), then this choice further depends on the random seed so that different runs can be made producing potentially different outcomes -- while still having deterministic behavior given the same random seed.
$